\Chapter{Tervezés}

\Section{Koncepció}
Mint látni lehet a Multi2Sim-nél, a szimuláció lehetséges megoldása a problémának, viszont roppant bonyolult és erőforrásigényes. Ebben a dolgozatban megpróbálunk egy sokkal egyszerűbb, kevésbé pontos megoldást kínálni ami remélhetőleg sokkal szemléltetőbb. 

Mivel a hardveres futás szimuláció kicsit bonyolult, ezért azt elvetve marad a futó program elemzése. Erre lehetőséget biztosít a GDB, egy GNU project debugger, de ennek a precizitása kétséges, illetve csak a házigazda program futásának elemzésére alkalmas. A másik vizsgálandó megoldás a forráskód elemzése.

 Az OpenCl működésének ismeretével lehetséges lehet olyan alkalmazást létrehozni, ami a forráskódban felismeri az OpenCL elemeit, és helyesen megtippeli hogy azok mit csinálnának. Így felépíthető lenne egy modell az adott OpenCL program működéséről amit már csak megjeleníteni szükséges.
 
\Section{Gazdaprogram elemei}
Az OpenCL programok egy jelentős része a házigazda programban történik, aminek nagyon sok kötelező eleme van, mint például a platformok keresése. Ezeket a program megkeresi és feljegyzi, hogy majd később megjeleníthesse őket. Legnagyobb részük 1 szálon szekvenciálisan fut, és OpenCL elemekkel dolgoznak, mint pédául DeviceID-kkal vagy OpenCL platformokkal. Elemzési teendő így nem nagyon van. Ekkor a házigazda program nagy része már modellezve is van.

Ilyen elemek lehetnek a platform, memóriák felszabadítása, kernel létrehozás, OpenCL program készítése, parancs sor készítése, környezet létrehozása, egyebek.



\Section{Teendők a kernellel}
Igazából a kernelben található konkrét műveletek elemzési, vizualizációs szempontokból elhanyagolhatók. Ami ott fontos és ajánlott vele foglalkozni, azok a szinkronizációs függvények, például egy sorompót érdemes lehet grafikusan megjeleníteni.

\Section{Munka elemek}
Egy fontosabb részlete az elemzésnek a munka elemek számának megállapítása. Ideális esetben megvan határozva a munkacsoport elemeinek száma, és ez kiolvasható a forráskódból. Ha ez nincs meghatározva, meg kell tippelnünk a számukat az OpenCL specifikáció alapján. Ezután rá tudunk jönni a munkacsoportok számára az NDRange és a kernel input alapján.

\Section{Program felépítése}

\begin{figure}[h]
\centering
\includegraphics[scale=0.5]{images/UML.jpg}
\caption{INITIAL UML osztálydiagram}
\label{fig:uml}
\end{figure}

A program működése a következő:

A webalkalmazáson át feltöltünk egy forrásfájlt, majd a szerver a fájlt beolvassa soronként. Megvizsgálja hogy a forrásfájl milyen OpenCL eszközöket használ, hány munka elem van benne, stb. A szerver ezután lekéri a számítógép architektúráját. Következő lépésben a webalkalmazás megrajzolja a számítógép ide vonatkozó Hardware elemeit, mint a rendelkezésre álló memória, a processzor adatai, a videókártya adatai, valamint felvázolja hogy az architektúrát milyen módon használná az OpenCL program. A szerver megkeresi a forrásfájlban az OpenCL függvényeket, és szükségszerűen modelleket rendell hozzájuk, vagyis megfelelő objektumokat hoz létre, például a \texttt{clCreateKernel} metódust észlelve létrehozunk egy Kernel objektumot.Ilyenkor azt is megállapítja, hogy az adott elem melyik Compute Unit-hoz tartozik. Ha ez sikeres, a webalkalmazás egy Gantt diagramban vizualizálja a program futtatását az idő függvényében. A webalkalmazás ezzel szinkronban megjeleníti magát a forráskódot is, és bármely Gantt diagrambeli elemre kattintva kiemeli a megfelelő kódot.

A program másik fele az Aritmetikai szimulációval foglalkozik. Ennek szükséglete lenne a forrásfájl "lefordítása" és futtatása, viszont a fordítás teljes folyamata meghaladja a dolgozatot. Kompromisszumos megoldás az első lépések, vagyis a lexikai analízis, szintaktikai analízis, szemantikai analízis, illetve később a kód optimalizálás kihagyása. A szimuláció így "kitalált" elemekkel dolgozik amit vagy a fájlnév alapján hoz létre, vagy mi magunk adhatunk meg. Ezek az elemek a Intermediate Code elemei amiket instrukcióknak nevezünk. Ha ezek megvannak, akkor az alkalmazás szimulálja őket, feljegyzi a instrukció lépés számot, a minimális memória igényt és a futási időt, valamint létrehoz egy szintaktikai fát az instrukciók alapján. A szimuláció ténylegesen elvégzi a lépéseket, létrehoz változókat, műveleteket végez rajtuk, és végül kiírja az eredményeket.

\begin{figure}[h]
\centering
\includegraphics[scale=0.4]{images/Compiler.jpg}
\caption{Fordító és módosításai}
\label{fig:compiler}
\end{figure}



°%\Section{Táblázatok}

%Táblázatokhoz a \texttt{table} környezetet ajánlott használni.
%Erre egy minta \aref{tab:minta}. táblázat.
%A hivatkozáshoz az egyedi \texttt{label} értéke konvenció szerint \texttt{tab:} prefixszel kezdődik.

%\begin{table}[h]
%\centering
%\caption{Minta táblázat. A táblázat felirata a táblázat felett kell legyen!}
%\label{tab:minta}
%\begin{tabular}{l|c|c|}
%a & b & c \\
%\hline
%1 & 2 & 3 \\
%4 & 5 & 6 \\
%\hline
%\end{tabular}
%\end{table}

%\Section{Ábrák}

%Ábrákat a \texttt{figure} környezettel lehet használni.
%A használatára egy példa \aref{fig:cimer}. ábrán látható.
%Az \texttt{includegraphics} parancsba 
%Az ábrák felirata az ábra alatt kell legyen.
%Az ábrák hivatkozásához használt nevet konvenció szerint \texttt{fig:}-el célszerű kezdeni.

%\begin{figure}[h]
%\centering
%\includegraphics[scale=0.3]{images/me_logo.png}
%\caption{A Miskolci Egyetem címere.}
%\label{fig:cimer}
%\end{figure}

%\Section{További környezetek}

%A matematikai témájú dolgozatokban szükség lehet tételek és bizonyításaik megadására.
%Ehhez szintén vannak készen elérhető környezetek.

%\begin{definition}
%Ez egy definíció
%\end{definition}

%\begin{lemma}
%Ez egy lemma
%\end{lemma}

%\begin{theorem}
%Ez egy tétel
%\end{theorem}

%\begin{proof}
%Ez egy bizonyítás
%\end{proof}

%\begin{corollary}
%Ez egy tétel
%\end{corollary}

%\begin{remark}
%Ez egy megjegyzés
%\end{remark}

%\begin{example}
%Ez egy példa
%\end{example}
